{"version":3,"file":"static/js/342.af48edd9.chunk.js","mappings":"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","sources":["lib/supabaseClient.js","lib/apiService.js"],"sourcesContent":["/**\n * Supabase Client Configuration\n * Handles all database and storage connections\n */\n\nimport { createClient } from '@supabase/supabase-js';\n\n// Get configuration from environment variables\nconst supabaseUrl = process.env.REACT_APP_SUPABASE_URL || 'https://placeholder.supabase.co';\nconst supabaseAnonKey = process.env.REACT_APP_SUPABASE_ANON_KEY || 'placeholder-key';\n\n// Create Supabase client with configuration\nexport const supabase = createClient(supabaseUrl, supabaseAnonKey, {\n  auth: {\n    autoRefreshToken: true,\n    persistSession: true,\n    detectSessionInUrl: true,\n    storage: window.localStorage,\n    storageKey: 'supabase.auth.token',\n    flowType: 'pkce'\n  },\n  realtime: {\n    enabled: true\n  },\n  global: {\n    headers: {\n      'X-Client-Info': 'fileinasnap-frontend'\n    }\n  }\n});\n\n// Auth helper functions\nexport const auth = {\n  // Sign up with email and password\n  async signUp(email, password, userData = {}) {\n    const { data, error } = await supabase.auth.signUp({\n      email,\n      password,\n      options: {\n        data: {\n          full_name: userData.fullName || '',\n          avatar_url: '',\n          ...userData\n        }\n      }\n    });\n    \n    if (error) throw error;\n    return data;\n  },\n\n  // Sign in with email and password\n  async signIn(email, password) {\n    const { data, error } = await supabase.auth.signInWithPassword({\n      email,\n      password\n    });\n    \n    if (error) throw error;\n    return data;\n  },\n\n  // Sign in with Google\n  async signInWithGoogle() {\n    const { data, error } = await supabase.auth.signInWithOAuth({\n      provider: 'google',\n      options: {\n        redirectTo: `${window.location.origin}/dashboard`,\n        queryParams: {\n          access_type: 'offline',\n          prompt: 'consent',\n        }\n      }\n    });\n    \n    if (error) throw error;\n    return data;\n  },\n\n  // Sign out\n  async signOut() {\n    const { error } = await supabase.auth.signOut();\n    if (error) throw error;\n  },\n\n  // Get current user\n  async getCurrentUser() {\n    const { data: { user }, error } = await supabase.auth.getUser();\n    if (error) throw error;\n    return user;\n  },\n\n  // Reset password\n  async resetPassword(email) {\n    const { data, error } = await supabase.auth.resetPasswordForEmail(email, {\n      redirectTo: `${window.location.origin}/reset-password`\n    });\n    \n    if (error) throw error;\n    return data;\n  },\n\n  // Update password\n  async updatePassword(newPassword) {\n    const { data, error } = await supabase.auth.updateUser({\n      password: newPassword\n    });\n    \n    if (error) throw error;\n    return data;\n  },\n\n  // Update user profile\n  async updateProfile(updates) {\n    const { data, error } = await supabase.auth.updateUser({\n      data: updates\n    });\n    \n    if (error) throw error;\n    return data;\n  }\n};\n\n// Storage helper functions\nexport const storage = {\n  // Upload file to storage\n  async uploadFile(bucket, path, file, options = {}) {\n    const { data, error } = await supabase.storage\n      .from(bucket)\n      .upload(path, file, {\n        cacheControl: '3600',\n        upsert: false,\n        ...options\n      });\n    \n    if (error) throw error;\n    return data;\n  },\n\n  // Get public URL for file\n  getPublicUrl(bucket, path) {\n    const { data } = supabase.storage\n      .from(bucket)\n      .getPublicUrl(path);\n    \n    return data.publicUrl;\n  },\n\n  // Get signed URL for private file\n  async getSignedUrl(bucket, path, expiresIn = 3600) {\n    const { data, error } = await supabase.storage\n      .from(bucket)\n      .createSignedUrl(path, expiresIn);\n    \n    if (error) throw error;\n    return data.signedUrl;\n  },\n\n  // Delete file from storage\n  async deleteFile(bucket, paths) {\n    const pathArray = Array.isArray(paths) ? paths : [paths];\n    const { data, error } = await supabase.storage\n      .from(bucket)\n      .remove(pathArray);\n    \n    if (error) throw error;\n    return data;\n  },\n\n  // List files in bucket\n  async listFiles(bucket, path = '', options = {}) {\n    const { data, error } = await supabase.storage\n      .from(bucket)\n      .list(path, {\n        limit: 100,\n        offset: 0,\n        sortBy: { column: 'created_at', order: 'desc' },\n        ...options\n      });\n    \n    if (error) throw error;\n    return data;\n  }\n};\n\n// Database helper functions\nexport const db = {\n  // Generic select query\n  async select(table, columns = '*', filters = {}) {\n    let query = supabase.from(table).select(columns);\n    \n    // Apply filters\n    Object.entries(filters).forEach(([key, value]) => {\n      if (key.includes('.')) {\n        // Handle nested filters like 'user.eq.123'\n        const [column, operator] = key.split('.');\n        query = query[operator](column, value);\n      } else {\n        query = query.eq(key, value);\n      }\n    });\n    \n    const { data, error } = await query;\n    if (error) throw error;\n    return data;\n  },\n\n  // Generic insert\n  async insert(table, data) {\n    const { data: result, error } = await supabase\n      .from(table)\n      .insert(data)\n      .select();\n    \n    if (error) throw error;\n    return result;\n  },\n\n  // Generic update\n  async update(table, id, updates) {\n    const { data, error } = await supabase\n      .from(table)\n      .update(updates)\n      .eq('id', id)\n      .select();\n    \n    if (error) throw error;\n    return data;\n  },\n\n  // Generic delete\n  async delete(table, id) {\n    const { data, error } = await supabase\n      .from(table)\n      .delete()\n      .eq('id', id);\n    \n    if (error) throw error;\n    return data;\n  },\n\n  // Count records\n  async count(table, filters = {}) {\n    let query = supabase.from(table).select('*', { count: 'exact', head: true });\n    \n    Object.entries(filters).forEach(([key, value]) => {\n      query = query.eq(key, value);\n    });\n    \n    const { count, error } = await query;\n    if (error) throw error;\n    return count;\n  }\n};\n\n// Real-time subscriptions\nexport const realtime = {\n  // Subscribe to table changes\n  subscribeToTable(table, callback, filters = {}) {\n    let subscription = supabase\n      .channel(`public:${table}`)\n      .on('postgres_changes', {\n        event: '*',\n        schema: 'public',\n        table: table,\n        ...filters\n      }, callback);\n    \n    subscription.subscribe();\n    return subscription;\n  },\n\n  // Subscribe to user's data changes\n  subscribeToUserData(userId, callback) {\n    const subscription = supabase\n      .channel('user-data')\n      .on('postgres_changes', {\n        event: '*',\n        schema: 'public',\n        table: 'folders',\n        filter: `user_id=eq.${userId}`\n      }, callback)\n      .on('postgres_changes', {\n        event: '*',\n        schema: 'public',\n        table: 'files',\n        filter: `user_id=eq.${userId}`\n      }, callback);\n    \n    subscription.subscribe();\n    return subscription;\n  },\n\n  // Unsubscribe from channel\n  unsubscribe(subscription) {\n    if (subscription) {\n      subscription.unsubscribe();\n    }\n  }\n};\n\n// Health check function\nexport async function checkSupabaseConnection() {\n  try {\n    const { data, error } = await supabase\n      .from('folders')\n      .select('count')\n      .limit(1);\n    \n    return {\n      connected: !error,\n      error: error?.message,\n      timestamp: new Date().toISOString()\n    };\n  } catch (error) {\n    return {\n      connected: false,\n      error: error.message,\n      timestamp: new Date().toISOString()\n    };\n  }\n}\n\n// Initialize auth state listener\nsupabase.auth.onAuthStateChange((event, session) => {\n  console.log('Auth state changed:', event, session?.user?.email);\n  \n  // Handle auth events\n  switch (event) {\n    case 'SIGNED_IN':\n      console.log('User signed in:', session?.user?.email);\n      break;\n    case 'SIGNED_OUT':\n      console.log('User signed out');\n      // Clear any cached data\n      localStorage.removeItem('cached-folders');\n      localStorage.removeItem('cached-files');\n      break;\n    case 'TOKEN_REFRESHED':\n      console.log('Token refreshed');\n      break;\n    default:\n      break;\n  }\n});\n\nexport default supabase;\n","/**\n * Advanced API Service for FileInASnap Dashboard\n * Handles all backend integration, Supabase connections, and AI features\n */\n\nimport { supabase } from './supabaseClient';\n\nclass ApiService {\n  constructor() {\n    this.baseURL = process.env.REACT_APP_API_URL || '/api';\n    this.retryAttempts = 3;\n    this.retryDelay = 1000;\n  }\n\n  // Generic request wrapper with retry logic\n  async request(url, options = {}) {\n    const fullUrl = url.startsWith('http') ? url : `${this.baseURL}${url}`;\n    \n    for (let attempt = 1; attempt <= this.retryAttempts; attempt++) {\n      try {\n        const response = await fetch(fullUrl, {\n          headers: {\n            'Content-Type': 'application/json',\n            ...options.headers\n          },\n          ...options\n        });\n\n        if (!response.ok) {\n          throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n        }\n\n        return await response.json();\n      } catch (error) {\n        console.error(`API request failed (attempt ${attempt}):`, error);\n        \n        if (attempt === this.retryAttempts) {\n          throw error;\n        }\n        \n        // Wait before retry\n        await new Promise(resolve => setTimeout(resolve, this.retryDelay * attempt));\n      }\n    }\n  }\n\n  // Authentication helper\n  getAuthHeaders() {\n    const token = localStorage.getItem('supabase.auth.token');\n    return token ? { 'Authorization': `Bearer ${token}` } : {};\n  }\n\n  // ========================================\n  // FOLDER MANAGEMENT\n  // ========================================\n\n  async getFolders() {\n    try {\n      // First try Supabase direct\n      const { data: user } = await supabase.auth.getUser();\n      if (!user?.user) {\n        throw new Error('Not authenticated');\n      }\n\n      const { data, error } = await supabase\n        .from('folders')\n        .select(`\n          id,\n          name,\n          created_at,\n          updated_at,\n          user_id,\n          files (count)\n        `)\n        .eq('user_id', user.user.id)\n        .order('name', { ascending: true });\n\n      if (error) throw error;\n\n      // Transform to include file count\n      return data.map(folder => ({\n        ...folder,\n        file_count: folder.files?.[0]?.count || 0\n      }));\n    } catch (error) {\n      console.warn('Supabase direct access failed, falling back to API:', error);\n      \n      // Fallback to API endpoint\n      try {\n        return await this.request('/folders', {\n          headers: this.getAuthHeaders()\n        });\n      } catch (apiError) {\n        console.error('API fallback also failed:', apiError);\n        \n        // Return mock data for development\n        return [\n          {\n            id: 'mock-1',\n            name: 'Quick Uploads',\n            file_count: 0,\n            created_at: new Date().toISOString()\n          },\n          {\n            id: 'mock-2', \n            name: 'Vacation Photos',\n            file_count: 12,\n            created_at: new Date().toISOString()\n          }\n        ];\n      }\n    }\n  }\n\n  async createFolder(name) {\n    try {\n      const { data: user } = await supabase.auth.getUser();\n      if (!user?.user) {\n        throw new Error('Not authenticated');\n      }\n\n      const { data, error } = await supabase\n        .from('folders')\n        .insert({\n          name,\n          user_id: user.user.id\n        })\n        .select()\n        .single();\n\n      if (error) throw error;\n      return { ...data, file_count: 0 };\n    } catch (error) {\n      console.warn('Supabase folder creation failed, falling back to API:', error);\n      \n      return await this.request('/folders', {\n        method: 'POST',\n        headers: this.getAuthHeaders(),\n        body: JSON.stringify({ name })\n      });\n    }\n  }\n\n  async deleteFolder(folderId) {\n    try {\n      const { error } = await supabase\n        .from('folders')\n        .delete()\n        .eq('id', folderId);\n\n      if (error) throw error;\n      return { success: true };\n    } catch (error) {\n      return await this.request(`/folders/${folderId}`, {\n        method: 'DELETE',\n        headers: this.getAuthHeaders()\n      });\n    }\n  }\n\n  // ========================================\n  // FILE MANAGEMENT\n  // ========================================\n\n  async getFiles(folderId = null, limit = 50, offset = 0) {\n    try {\n      const { data: user } = await supabase.auth.getUser();\n      if (!user?.user) {\n        throw new Error('Not authenticated');\n      }\n\n      let query = supabase\n        .from('files')\n        .select(`\n          id,\n          name,\n          size,\n          type,\n          path,\n          public_url,\n          thumbnail_url,\n          folder_id,\n          created_at,\n          updated_at,\n          metadata,\n          tags\n        `)\n        .eq('user_id', user.user.id)\n        .order('created_at', { ascending: false })\n        .range(offset, offset + limit - 1);\n\n      if (folderId) {\n        query = query.eq('folder_id', folderId);\n      }\n\n      const { data, error } = await query;\n\n      if (error) throw error;\n      return data || [];\n    } catch (error) {\n      console.warn('Supabase file fetch failed, falling back to API:', error);\n      \n      const url = `/files${folderId ? `?folder_id=${folderId}` : ''}`;\n      return await this.request(url, {\n        headers: this.getAuthHeaders()\n      });\n    }\n  }\n\n  async uploadFile(file, folderId, onProgress = null) {\n    try {\n      const { data: user } = await supabase.auth.getUser();\n      if (!user?.user) {\n        throw new Error('Not authenticated');\n      }\n\n      // Generate unique file path\n      const fileExt = file.name.split('.').pop();\n      const fileName = `${Date.now()}-${Math.random().toString(36).substring(2)}.${fileExt}`;\n      const filePath = `${user.user.id}/${folderId}/${fileName}`;\n\n      // Upload to Supabase Storage\n      const { data: uploadData, error: uploadError } = await supabase.storage\n        .from('files')\n        .upload(filePath, file, {\n          cacheControl: '3600',\n          upsert: false\n        });\n\n      if (uploadError) throw uploadError;\n\n      // Get public URL\n      const { data: { publicUrl } } = supabase.storage\n        .from('files')\n        .getPublicUrl(filePath);\n\n      // Determine file type\n      const fileType = this.getFileType(file);\n\n      // Save metadata to database\n      const { data: fileRecord, error: dbError } = await supabase\n        .from('files')\n        .insert({\n          name: file.name,\n          size: file.size,\n          type: fileType,\n          path: filePath,\n          public_url: publicUrl,\n          folder_id: folderId,\n          user_id: user.user.id,\n          metadata: {\n            originalName: file.name,\n            mimeType: file.type,\n            uploadedAt: new Date().toISOString()\n          }\n        })\n        .select()\n        .single();\n\n      if (dbError) throw dbError;\n\n      // Trigger AI processing in background\n      this.triggerAIProcessing(fileRecord.id, publicUrl, fileType);\n\n      return fileRecord;\n    } catch (error) {\n      console.warn('Supabase upload failed, falling back to API:', error);\n      \n      // Fallback to traditional form upload\n      const formData = new FormData();\n      formData.append('file', file);\n      formData.append('folder_id', folderId);\n\n      return await this.request('/uploads', {\n        method: 'POST',\n        headers: {\n          ...this.getAuthHeaders(),\n          // Don't set Content-Type for FormData\n        },\n        body: formData\n      });\n    }\n  }\n\n  async deleteFile(fileId) {\n    try {\n      // Get file info first\n      const { data: file } = await supabase\n        .from('files')\n        .select('path')\n        .eq('id', fileId)\n        .single();\n\n      if (file?.path) {\n        // Delete from storage\n        await supabase.storage\n          .from('files')\n          .remove([file.path]);\n      }\n\n      // Delete from database\n      const { error } = await supabase\n        .from('files')\n        .delete()\n        .eq('id', fileId);\n\n      if (error) throw error;\n      return { success: true };\n    } catch (error) {\n      return await this.request(`/files/${fileId}`, {\n        method: 'DELETE',\n        headers: this.getAuthHeaders()\n      });\n    }\n  }\n\n  // ========================================\n  // SEARCH & AI FEATURES\n  // ========================================\n\n  async searchFiles(query, filters = {}) {\n    try {\n      const { data: user } = await supabase.auth.getUser();\n      if (!user?.user) {\n        throw new Error('Not authenticated');\n      }\n\n      // Build search query\n      let dbQuery = supabase\n        .from('files')\n        .select(`\n          id,\n          name,\n          size,\n          type,\n          path,\n          public_url,\n          thumbnail_url,\n          folder_id,\n          created_at,\n          metadata,\n          tags,\n          folders (name)\n        `)\n        .eq('user_id', user.user.id);\n\n      // Text search in name and tags\n      if (query) {\n        dbQuery = dbQuery.or(`name.ilike.%${query}%, tags.cs.{${query}}`);\n      }\n\n      // Apply filters\n      if (filters.type) {\n        dbQuery = dbQuery.eq('type', filters.type);\n      }\n      \n      if (filters.folder_id) {\n        dbQuery = dbQuery.eq('folder_id', filters.folder_id);\n      }\n\n      if (filters.date_from) {\n        dbQuery = dbQuery.gte('created_at', filters.date_from);\n      }\n\n      if (filters.date_to) {\n        dbQuery = dbQuery.lte('created_at', filters.date_to);\n      }\n\n      dbQuery = dbQuery.order('created_at', { ascending: false }).limit(100);\n\n      const { data, error } = await dbQuery;\n      if (error) throw error;\n\n      return data || [];\n    } catch (error) {\n      console.warn('Supabase search failed, falling back to API:', error);\n      \n      const params = new URLSearchParams({ \n        q: query,\n        ...filters \n      });\n      \n      return await this.request(`/search?${params}`, {\n        headers: this.getAuthHeaders()\n      });\n    }\n  }\n\n  async getAIInsights() {\n    try {\n      return await this.request('/ai/insights', {\n        headers: this.getAuthHeaders()\n      });\n    } catch (error) {\n      // Return mock insights for development\n      return {\n        total_files: 1247,\n        faces_detected: 156,\n        locations_identified: 45,\n        events_discovered: 23,\n        top_tags: ['vacation', 'family', 'nature', 'birthday', 'travel'],\n        processing_status: 'complete'\n      };\n    }\n  }\n\n  async triggerAIProcessing(fileId, fileUrl, fileType) {\n    try {\n      // Only process images and videos\n      if (!['image', 'video'].includes(fileType)) return;\n\n      await this.request('/ai/process', {\n        method: 'POST',\n        headers: this.getAuthHeaders(),\n        body: JSON.stringify({\n          file_id: fileId,\n          file_url: fileUrl,\n          file_type: fileType\n        })\n      });\n    } catch (error) {\n      console.warn('AI processing failed:', error);\n      // Non-blocking - don't throw\n    }\n  }\n\n  // ========================================\n  // STATISTICS & ANALYTICS\n  // ========================================\n\n  async getStats() {\n    try {\n      const { data: user } = await supabase.auth.getUser();\n      if (!user?.user) {\n        throw new Error('Not authenticated');\n      }\n\n      // Get folder count\n      const { count: folderCount } = await supabase\n        .from('folders')\n        .select('*', { count: 'exact', head: true })\n        .eq('user_id', user.user.id);\n\n      // Get file count and size\n      const { data: fileStats, error: fileError } = await supabase\n        .from('files')\n        .select('size')\n        .eq('user_id', user.user.id);\n\n      if (fileError) throw fileError;\n\n      const totalBytes = fileStats.reduce((sum, file) => sum + (file.size || 0), 0);\n      const totalMB = totalBytes / (1024 * 1024);\n\n      return {\n        folders: folderCount || 0,\n        files: fileStats.length || 0,\n        total_bytes: totalBytes,\n        total_mb: Math.round(totalMB * 100) / 100\n      };\n    } catch (error) {\n      console.warn('Supabase stats failed, falling back to API:', error);\n      \n      try {\n        return await this.request('/stats', {\n          headers: this.getAuthHeaders()\n        });\n      } catch (apiError) {\n        // Return mock stats for development\n        return {\n          folders: 8,\n          files: 1247,\n          total_bytes: 2147483648, // 2GB\n          total_mb: 2048\n        };\n      }\n    }\n  }\n\n  async getRecentActivity(limit = 10) {\n    try {\n      const { data: user } = await supabase.auth.getUser();\n      if (!user?.user) {\n        throw new Error('Not authenticated');\n      }\n\n      const { data, error } = await supabase\n        .from('files')\n        .select(`\n          id,\n          name,\n          type,\n          created_at,\n          folders (name)\n        `)\n        .eq('user_id', user.user.id)\n        .order('created_at', { ascending: false })\n        .limit(limit);\n\n      if (error) throw error;\n\n      return (data || []).map(file => ({\n        id: file.id,\n        action: 'uploaded',\n        item_name: file.name,\n        item_type: file.type,\n        folder_name: file.folders?.name,\n        timestamp: file.created_at,\n        description: `Uploaded ${file.name} to ${file.folders?.name || 'Unknown Folder'}`\n      }));\n    } catch (error) {\n      console.warn('Recent activity fetch failed:', error);\n      \n      // Return mock activity\n      return [\n        {\n          id: '1',\n          action: 'uploaded',\n          item_name: '12 vacation photos',\n          item_type: 'image',\n          folder_name: 'Vacation 2024',\n          timestamp: new Date(Date.now() - 2 * 60 * 60 * 1000).toISOString(),\n          description: 'Uploaded 12 photos from vacation'\n        },\n        {\n          id: '2',\n          action: 'organized',\n          item_name: 'Beach photos',\n          item_type: 'ai_processing',\n          folder_name: 'AI Organized',\n          timestamp: new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString(),\n          description: 'AI organized beach photos'\n        }\n      ];\n    }\n  }\n\n  // ========================================\n  // UTILITY FUNCTIONS\n  // ========================================\n\n  getFileType(file) {\n    if (file.type.startsWith('image/')) return 'image';\n    if (file.type.startsWith('video/')) return 'video';\n    if (file.type === 'application/pdf' || \n        file.type.includes('document') || \n        file.type.includes('text/')) return 'document';\n    return 'other';\n  }\n\n  formatFileSize(bytes) {\n    if (bytes === 0) return '0 Bytes';\n    const k = 1024;\n    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n  }\n\n  // ========================================\n  // HEALTH CHECK\n  // ========================================\n\n  async healthCheck() {\n    try {\n      // Check Supabase connection\n      const { data, error } = await supabase.from('folders').select('count').limit(1);\n      const supabaseOk = !error;\n\n      // Check API endpoint\n      let apiOk = false;\n      try {\n        await this.request('/health');\n        apiOk = true;\n      } catch (e) {\n        // API might not exist yet\n      }\n\n      return {\n        ok: supabaseOk || apiOk,\n        bucket_ok: supabaseOk,\n        rpc_ok: supabaseOk,\n        api_ok: apiOk,\n        timestamp: new Date().toISOString()\n      };\n    } catch (error) {\n      return {\n        ok: false,\n        bucket_ok: false,\n        rpc_ok: false,\n        api_ok: false,\n        error: error.message,\n        timestamp: new Date().toISOString()\n      };\n    }\n  }\n}\n\n// Export singleton instance\nexport const apiService = new ApiService();\nexport default apiService;\n"],"names":["supabaseUrl","process","REACT_APP_SUPABASE_URL","supabaseAnonKey","REACT_APP_SUPABASE_ANON_KEY","supabase","createClient","auth","autoRefreshToken","persistSession","detectSessionInUrl","storage","window","localStorage","storageKey","flowType","realtime","enabled","global","headers","onAuthStateChange","event","session","_session$user","_session$user2","console","log","user","email","removeItem","apiService","constructor","this","baseURL","REACT_APP_API_URL","retryAttempts","retryDelay","request","url","options","arguments","length","undefined","fullUrl","startsWith","concat","attempt","response","fetch","_objectSpread","ok","Error","status","statusText","json","error","Promise","resolve","setTimeout","getAuthHeaders","token","getItem","getFolders","data","getUser","from","select","eq","id","order","ascending","map","folder","_folder$files","_folder$files$","file_count","files","count","warn","apiError","name","created_at","Date","toISOString","createFolder","insert","user_id","single","method","body","JSON","stringify","deleteFolder","folderId","delete","success","getFiles","limit","offset","query","range","uploadFile","file","fileExt","split","pop","fileName","now","Math","random","toString","substring","filePath","uploadData","uploadError","upload","cacheControl","upsert","publicUrl","getPublicUrl","fileType","getFileType","fileRecord","dbError","size","type","path","public_url","folder_id","metadata","originalName","mimeType","uploadedAt","triggerAIProcessing","formData","FormData","append","deleteFile","fileId","remove","searchFiles","filters","dbQuery","or","date_from","gte","date_to","lte","params","URLSearchParams","q","getAIInsights","total_files","faces_detected","locations_identified","events_discovered","top_tags","processing_status","fileUrl","includes","file_id","file_url","file_type","getStats","folderCount","head","fileStats","fileError","totalBytes","reduce","sum","totalMB","folders","total_bytes","total_mb","round","getRecentActivity","_file$folders","_file$folders2","action","item_name","item_type","folder_name","timestamp","description","formatFileSize","bytes","i","floor","parseFloat","pow","toFixed","healthCheck","supabaseOk","apiOk","e","bucket_ok","rpc_ok","api_ok","message"],"sourceRoot":""}